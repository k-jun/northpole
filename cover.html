
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">northpole/match/match.go (88.2%)</option>
				
				<option value="file1">northpole/match/match_mock.go (0.0%)</option>
				
				<option value="file2">northpole/server/server.go (74.0%)</option>
				
				<option value="file3">northpole/storage/match_storage.go (92.6%)</option>
				
				<option value="file4">northpole/storage/match_storage_mock.go (0.0%)</option>
				
				<option value="file5">northpole/usecase/match_usecase.go (86.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package match

import (
        "sync"

        "github.com/google/uuid"

        pb "northpole/grpc"
        "northpole/user"
)

type Match interface {
        JoinUser(u *user.User) error
        LeaveUser(u *user.User) error
        ID() uuid.UUID
        Status() pb.MatchStatus
        Channel() chan Match
        MatchInfo() *pb.MatchInfo
}

type MatchImpl struct {
        sync.Mutex

        id               uuid.UUID
        status           pb.MatchStatus
        maxNumberOfUsers int
        users            []*user.User
        channel          chan Match
}

var (
        maxNumberOfUser = 4
)

func New(id uuid.UUID) Match <span class="cov8" title="1">{
        return &amp;MatchImpl{
                id:               id,
                status:           pb.MatchStatus_Availabel,
                maxNumberOfUsers: maxNumberOfUser,
                users:            []*user.User{},
                channel:          make(chan Match, maxNumberOfUser),
        }
}</span>

func (m *MatchImpl) ID() uuid.UUID <span class="cov0" title="0">{
        return m.id
}</span>

func (m *MatchImpl) Status() pb.MatchStatus <span class="cov0" title="0">{
        return m.status
}</span>

func (m *MatchImpl) Channel() chan Match <span class="cov0" title="0">{
        return m.channel
}</span>

func (m *MatchImpl) JoinUser(inUser *user.User) error <span class="cov8" title="1">{
        m.Lock()
        defer m.Unlock()

        if m.status != pb.MatchStatus_Availabel </span><span class="cov8" title="1">{
                return MatchUnavailableErr
        }</span>

        <span class="cov8" title="1">m.users = append(m.users, inUser)
        if len(m.users) &gt;= m.maxNumberOfUsers </span><span class="cov8" title="1">{
                m.status = pb.MatchStatus_Unavailabel
        }</span>

        <span class="cov8" title="1">go m.broadcast(*m)
        return nil</span>
}

func (m *MatchImpl) LeaveUser(outUser *user.User) error <span class="cov8" title="1">{
        m.Lock()
        defer m.Unlock()

        if m.status != pb.MatchStatus_Availabel </span><span class="cov0" title="0">{
                return MatchUnavailableErr
        }</span>

        <span class="cov8" title="1">found := false
        for i, user := range m.users </span><span class="cov8" title="1">{
                if user.ID() == outUser.ID() </span><span class="cov8" title="1">{
                        m.users[i] = m.users[0]
                        m.users = m.users[1:]
                        found = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return MatchUserNotFound
        }</span>

        <span class="cov8" title="1">if len(m.users) == 0 </span><span class="cov8" title="1">{
                m.status = pb.MatchStatus_Unavailabel
                close(m.channel)
        }</span> else<span class="cov8" title="1"> {
                go m.broadcast(*m)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (m *MatchImpl) broadcast(match MatchImpl) <span class="cov8" title="1">{
        for i := 0; i &lt; len(m.users); i++ </span><span class="cov8" title="1">{
                m.channel &lt;- &amp;match
        }</span>
}

func (m *MatchImpl) MatchInfo() *pb.MatchInfo <span class="cov8" title="1">{
        return &amp;pb.MatchInfo{
                Id:                   m.id.String(),
                Status:               m.status,
                CurrentNumberOfUsers: int64(len(m.users)),
                MaxNumberOfUsers:     int64(m.maxNumberOfUsers),
        }
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package match

import (
        pb "northpole/grpc"
        "northpole/user"

        "github.com/google/uuid"
)

type MatchMock struct {
        ErrorMock  error
        StatusMock pb.MatchStatus
        IDMock     uuid.UUID
}

func (m MatchMock) JoinUser(u *user.User) error <span class="cov0" title="0">{
        return m.ErrorMock
}</span>

func (m MatchMock) LeaveUser(u *user.User) error <span class="cov0" title="0">{
        return m.ErrorMock
}</span>

func (m MatchMock) ID() uuid.UUID <span class="cov0" title="0">{
        return m.IDMock
}</span>

func (m MatchMock) Status() pb.MatchStatus <span class="cov0" title="0">{
        return m.StatusMock
}</span>

func (m MatchMock) Channel() chan Match <span class="cov0" title="0">{
        return nil
}</span>

func (m MatchMock) MatchInfo() *pb.MatchInfo <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package server

import (
        "context"

        pb "northpole/grpc"
        "northpole/match"
        "northpole/usecase"
        "northpole/user"

        "northpole/storage"

        "github.com/google/uuid"
        "google.golang.org/grpc"
)

var port = 8080

type northPoleServer struct {
        matchUsecase usecase.MatchUsecase
}

func (s *northPoleServer) JoinPublicMatch(userInfo *pb.UserInfo, stream pb.NorthPole_JoinPublicMatchServer) error <span class="cov8" title="1">{
        userId, err := uuid.Parse(userInfo.Id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">u := user.New(userId)

        m, err := s.matchUsecase.JoinPublicMatch(u)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                cm := &lt;-m.Channel()
                if cm.ID() == uuid.Nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">stream.Send(cm.MatchInfo())</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *northPoleServer) CreatePrivateMatch(userInfo *pb.UserInfo, stream pb.NorthPole_CreatePrivateMatchServer) error <span class="cov8" title="1">{
        userId, err := uuid.Parse(userInfo.Id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">u := user.New(userId)

        m, err := s.matchUsecase.CreatePrivateMatch(u)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                cm := &lt;-m.Channel()
                if cm.ID() == uuid.Nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">stream.Send(cm.MatchInfo())</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *northPoleServer) JoinPrivateMatch(midAndUid *pb.MatchIDAndUserID, stream pb.NorthPole_JoinPrivateMatchServer) error <span class="cov8" title="1">{
        userId, err := uuid.Parse(midAndUid.UserId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">u := user.New(userId)
        matchId, err := uuid.Parse(midAndUid.MatchId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">m := match.New(matchId)

        m, err = s.matchUsecase.JoinPrivateMatch(u, m)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                cm := &lt;-m.Channel()
                if cm.ID() == uuid.Nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">stream.Send(cm.MatchInfo())</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *northPoleServer) LeavePublicMatch(ctx context.Context, midAndUid *pb.MatchIDAndUserID) (*pb.MatchInfo, error) <span class="cov8" title="1">{
        userId, err := uuid.Parse(midAndUid.UserId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">u := user.New(userId)
        matchId, err := uuid.Parse(midAndUid.MatchId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">m := match.New(matchId)

        m, err = s.matchUsecase.LeavePublicMatch(u, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return m.MatchInfo(), nil</span>
}

func (s *northPoleServer) LeavePrivateMatch(ctx context.Context, midAndUid *pb.MatchIDAndUserID) (*pb.MatchInfo, error) <span class="cov8" title="1">{
        userId, err := uuid.Parse(midAndUid.UserId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">u := user.New(userId)
        matchId, err := uuid.Parse(midAndUid.MatchId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">m := match.New(matchId)

        m, err = s.matchUsecase.LeavePrivateMatch(u, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return m.MatchInfo(), nil</span>
}

func NewServer() *grpc.Server <span class="cov8" title="1">{
        grpcServer := grpc.NewServer()

        pubms := storage.NewMatchStorage()
        prims := storage.NewMatchStorage()
        matchUsecase := usecase.NewMatchUsecase(pubms, prims)
        pb.RegisterNorthPoleServer(grpcServer, &amp;northPoleServer{matchUsecase: matchUsecase})
        return grpcServer
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package storage

import (
        pb "northpole/grpc"
        "northpole/match"
        "sync"

        "github.com/google/uuid"
)

type MatchStorage interface {
        Find(match.Match) (match.Match, error)
        FindFirst() (match.Match, error)
        Add(m match.Match) error
        Remove(m match.Match) error
}

type matchStorageImpl struct {
        sync.RWMutex
        matches map[uuid.UUID]match.Match
}

func NewMatchStorage() MatchStorage <span class="cov0" title="0">{
        return &amp;matchStorageImpl{
                matches: map[uuid.UUID]match.Match{},
        }
}</span>

func (ms *matchStorageImpl) Find(m match.Match) (match.Match, error) <span class="cov8" title="1">{
        ms.RLock()
        defer ms.RUnlock()

        if m.ID() == uuid.Nil </span><span class="cov0" title="0">{
                return nil, MatchStorageBadParameter
        }</span>
        <span class="cov8" title="1">m = ms.matches[m.ID()]
        if m == nil </span><span class="cov8" title="1">{
                return nil, MatchStorageMatchNotFound
        }</span>

        <span class="cov8" title="1">return m, nil</span>
}

func (ms *matchStorageImpl) FindFirst() (match.Match, error) <span class="cov8" title="1">{
        ms.RLock()
        defer ms.RUnlock()

        for _, match := range ms.matches </span><span class="cov8" title="1">{
                if match.Status() == pb.MatchStatus_Availabel </span><span class="cov8" title="1">{
                        return match, nil
                }</span>
        }
        <span class="cov8" title="1">return nil, MatchStorageMatchNotFound</span>
}

func (ms *matchStorageImpl) Add(m match.Match) error <span class="cov8" title="1">{
        ms.Lock()
        defer ms.Unlock()

        if ms.matches[m.ID()] != nil </span><span class="cov8" title="1">{
                return MatchStorageMatchAlreadyExistErr
        }</span>
        <span class="cov8" title="1">ms.matches[m.ID()] = m

        return nil</span>
}

func (ms *matchStorageImpl) Remove(m match.Match) error <span class="cov8" title="1">{
        ms.Lock()
        defer ms.Unlock()

        if ms.matches[m.ID()] == nil </span><span class="cov8" title="1">{
                return MatchStorageMatchNotFound
        }</span>
        <span class="cov8" title="1">delete(ms.matches, m.ID())

        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package storage

import (
        "northpole/match"
)

type MatchStorageMock struct {
        MatchMock match.Match
        ErrorMock error
}

func (ms MatchStorageMock) Find(m match.Match) (match.Match, error) <span class="cov0" title="0">{
        return ms.MatchMock, ms.ErrorMock
}</span>

func (ms MatchStorageMock) FindFirst() (match.Match, error) <span class="cov0" title="0">{
        return ms.MatchMock, ms.ErrorMock
}</span>

func (ms MatchStorageMock) Add(m match.Match) error <span class="cov0" title="0">{
        return ms.ErrorMock
}</span>

func (ms MatchStorageMock) Remove(m match.Match) error <span class="cov0" title="0">{
        return ms.ErrorMock
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package usecase

import (
        "northpole/match"
        "northpole/storage"
        "northpole/user"
        "northpole/utils"
)

type MatchUsecase interface {
        JoinPublicMatch(*user.User) (match.Match, error)
        JoinPrivateMatch(*user.User, match.Match) (match.Match, error)
        CreatePrivateMatch(*user.User) (match.Match, error)
        LeavePublicMatch(*user.User, match.Match) (match.Match, error)
        LeavePrivateMatch(*user.User, match.Match) (match.Match, error)
}

type matchUsecaseImpl struct {
        publicMatchStorage  storage.MatchStorage
        privateMatchStorage storage.MatchStorage
}

func NewMatchUsecase(pubms storage.MatchStorage, prims storage.MatchStorage) MatchUsecase <span class="cov0" title="0">{
        return &amp;matchUsecaseImpl{
                publicMatchStorage:  pubms,
                privateMatchStorage: prims,
        }
}</span>

func (mu *matchUsecaseImpl) JoinPublicMatch(u *user.User) (match.Match, error) <span class="cov8" title="1">{
        m, err := mu.publicMatchStorage.FindFirst()
        if err != nil </span><span class="cov8" title="1">{
                if err == storage.MatchStorageMatchNotFound </span><span class="cov0" title="0">{
                        m = match.New(utils.NewUUID())
                        if err = mu.publicMatchStorage.Add(m); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                } else<span class="cov8" title="1"> {
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">if err = m.JoinUser(u); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return m, nil</span>
}

func (mu *matchUsecaseImpl) JoinPrivateMatch(u *user.User, m match.Match) (match.Match, error) <span class="cov8" title="1">{
        m, err := mu.privateMatchStorage.Find(m)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = m.JoinUser(u)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return m, nil</span>
}

func (mu *matchUsecaseImpl) CreatePrivateMatch(u *user.User) (match.Match, error) <span class="cov8" title="1">{
        m := match.New(utils.NewUUID())
        if err := mu.privateMatchStorage.Add(m); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := m.JoinUser(u); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return m, nil</span>
}

func (mu *matchUsecaseImpl) LeavePublicMatch(u *user.User, m match.Match) (match.Match, error) <span class="cov8" title="1">{
        m, err := mu.publicMatchStorage.Find(m)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err = m.LeaveUser(u); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return m, nil</span>
}

func (mu *matchUsecaseImpl) LeavePrivateMatch(u *user.User, m match.Match) (match.Match, error) <span class="cov8" title="1">{
        m, err := mu.privateMatchStorage.Find(m)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err = m.LeaveUser(u); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return m, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
